# 关键

## 线程的基本操作

每个程序至少有一个执行 `main()` 函数的线程，其他线程与主线程同时运行。如 `main()` 函数执行完会退出一样，线程执行完函数也会退出。为线程创建 `std::thread` 对象后，需要等待这个线程结束。

### 启动线程

简单来说，使用C++线程库启动线程，就是构造 `std::thread` 对象。

Lambda表达式

### 等待线程完成

只能对一个线程使用一次 `join()` ，一旦使用过 `join()` ，`std::thread` 对象就不能再次汇入了。当对其使用 `joinable()` 时，将返回 `false` 。

### 特殊情况下的等待

通常，在无异常的情况下使用 `join()` 时，需要在异常处理过程中调用 `join()` ，从而避免生命周期的问题。

“资源获取即初始化方式”(RAII，Resource Acquisition Is Initialization)

拷贝构造函数和拷贝赋值操作标记为 `=delete` ，是为了不让编译器自动生成。直接对对象进行拷贝或赋值是很危险的，因为这可能会弄丢已汇入的线程。通过删除声明，任何尝试给thread_guard对象赋值的操作都会引发一个编译错误。

### 后台运行线程

使用detach\(\)会让线程在后台运行，这就意味着与主线程不能直接交互。如果线程分离，就不可能有`std::thread`对象能引用它，分离线程的确在后台运行，所以分离的线程不能汇入。不过C++运行库保证，当线程退出时，相关资源的能够正确回收。

分离线程通常称为*守护线程*(daemon threads)。UNIX中守护线程，是指没有任何显式的接口，并在后台运行的线程，这种线程的特点就是长时间运行。线程的生命周期可能会从应用的起始到结束，可能会在后台监视文件系统，还有可能对缓存进行清理，亦或对数据结构进行优化。另外，分离线程只能确定线程什么时候结束，_发后即忘_\(fire and forget\)的任务使用到就是分离线程。

## 传递参数

向可调用对象或函数传递参数很简单，只需要将这些参数作为 `std::thread`构造函数的附加参数即可。需要注意的是，这些参数会拷贝至新线程的内存空间中(同临时变量一样)。即使函数中的参数是引用的形式，拷贝操作也会执行。

`std::unique_ptr`

C++标准线程库中和`std::unique_ptr`在所属权上相似的类有好几种，`std::thread`为其中之一。虽然，`std::thread`不像`std::unique_ptr`能占有动态对象的所有权，但是它能占有其他资源：每个实例都负责管理一个线程。线程的所有权可以在多个`std::thread`实例中转移，这依赖于`std::thread`实例的*可移动*且*不可复制*性。不可复制性表示在某一时间点，一个`std::thread`实例只能关联一个执行线程。可移动性使得开发者可以自己决定，哪个实例拥有线程实际执行的所有权。

## 转移所有权

C++标准库中有很多*资源占有*(resource-owning)类型，比如`std::ifstream`，`std::unique_ptr`还有`std::thread`都是可移动，但不可复制。这说明执行线程的所有权可以在`std::thread`实例中移动。

不能通过赋新值给`std::thread`对象的方式来"丢弃"一个线程。

`std::thread`支持移动，线程的所有权可以在函数外进行转移。

`jthread` -- [joining_thread](../code/joining_thread.h)

[vector_thread](../code/vector_thread.cpp)

## 确定线程数量

[std::accmulate](../code/accumulate.h)

当线程运行时，所有必要的信息都需要传入到线程中去，包括存储计算结果的位置。有时候可以传递一个标识数。不过，需要标识的函数在调用栈的底层，同时其他线程也可调用该函数，那么标识数就会变成累赘。好消息是在设计C++的线程库时，就有预见了这种情况，实现中给每个线程附加了唯一标识符。

## 线程标识

线程标识为`std::thread::id`类型，可以通过两种方式进行检索。第一种，可以通过调用`std::thread`对象的成员函数`get_id()`来直接获取。如果`std::thread`对象没有与任何执行线程相关联，`get_id()`将返回`std::thread::type`默认构造值，这个值表示“无线程”。第二种，当前线程中调用`std::this_thread::get_id()`(这个函数定义在`<thread>`头文件中)也可以获得线程标识。

`std::thread::id`对象可以自由的拷贝和对比，因为标识符可以复用。